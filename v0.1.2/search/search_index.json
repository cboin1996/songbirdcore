{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"songbirdcore \ud83d\udc26 music download engine","text":"<p>Hello, and welcome to <code>songbirdcore</code>.</p> <p>Get started by installing the <code>songbirdcore</code> package</p> <pre><code>pip install songbirdcore\n</code></pre>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>To view what features are available, please see the API documentation header at the top of this page!</p>"},{"location":"songbirdcore/common/","title":"common","text":""},{"location":"songbirdcore/common/#songbirdcore.common","title":"<code>songbirdcore.common</code>","text":""},{"location":"songbirdcore/common/#songbirdcore.common.find_file","title":"<code>find_file(path, filename)</code>","text":"<p>Simple glob search for a file</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>the path to the root folder to search within</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>the filename (supports glob patterns)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: list of paths found that match</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def find_file(path: str, filename: str) -&gt; List[str]:\n    \"\"\"Simple glob search for a file\n\n    Args:\n        path (str): the path to the root folder to search within\n        filename (str): the filename (supports glob patterns)\n\n    Returns:\n        List[str]: list of paths found that match\n    \"\"\"\n    paths = glob.glob(os.path.join(path, filename))\n    return paths\n</code></pre>"},{"location":"songbirdcore/common/#songbirdcore.common.fname_duper","title":"<code>fname_duper(fname, limit, count, dup_key)</code>","text":"<p>Generates a duplicate filename for when a filename already exists</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>filename</p> </li> <li> <code>limit</code>               (<code>int</code>)           \u2013            <p>a limit of dups before quitting the attempt</p> </li> <li> <code>count</code>               (<code>int</code>)           \u2013            <p>recursive count tracker</p> </li> <li> <code>dup_key</code>               (<code>str</code>)           \u2013            <p>the key to use as the duplicate addon</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: the modified filename, or None if the limit has been reached.</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def fname_duper(fname: str, limit: int, count: int, dup_key: str) -&gt; Optional[str]:\n    \"\"\"Generates a duplicate filename for when a filename already exists\n\n    Args:\n        fname (str): filename\n        limit (int): a limit of dups before quitting the attempt\n        count (int): recursive count tracker\n        dup_key (str): the key to use as the duplicate addon\n\n    Returns:\n        Optional[str]: the modified filename, or None if the limit has been reached.\n    \"\"\"\n    fname_split = os.path.splitext(fname)\n    fname_noext = fname_split[0]\n    ext = fname_split[1]\n    if count == limit:\n        logger.error(\n            f\"Max retry limit {limit} reached for fname {fname}. Please try changing some filenames and try again later.\"\n        )\n        return None\n    if os.path.exists(fname):\n        fname = fname_duper(fname_noext + dup_key + ext, limit, count + 1, dup_key)\n\n    return fname\n</code></pre>"},{"location":"songbirdcore/common/#songbirdcore.common.name_plate","title":"<code>name_plate(entries)</code>","text":"<p>renders the songbird entrypoint name plate</p> <p>Parameters:</p> <ul> <li> <code>entries</code>               (<code>List[str]</code>)           \u2013            <p>add additional entries to the nameplate via this list</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def name_plate(entries: List[str]) -&gt; None:\n    \"\"\"renders the songbird entrypoint name plate\n\n    Args:\n        entries (List[str]): add additional entries to the nameplate via this list\n    \"\"\"\n    # load project version from file\n    print(\"===============================\")\n    print(\"=----Welcome to songbird\ud83d\udc26----=\")\n    print(\"===============================\")\n    print(f\"--songbirdcore {version}\")\n    for entry in entries:\n        print(entry)\n    print(\"===============================\")\n    print(\"Message from developer:\")\n    print(\n        \"\\t- dependencies have been upgraded, make sure you have run 'playwright install'.\"\n    )\n    print(\n        \"\\t- If you encounter errors, please create an issue here https://github.com/cboin1996/songbirdcore/issues/\"\n    )\n    print(\n        f\"At the main menu, type one of {[mode.value for mode in modes.Modes]} to switch modes!\"\n    )\n</code></pre>"},{"location":"songbirdcore/common/#songbirdcore.common.pretty_list_of_basemodel_printer","title":"<code>pretty_list_of_basemodel_printer(list_of_models, ignore_keys=None)</code>","text":"<p>renders a list to stdio given a list of pydantic BaseModel objects</p> <p>Parameters:</p> <ul> <li> <code>list_of_models</code>               (<code>List[BaseModel]</code>)           \u2013            <p>list of pydantic models to print</p> </li> <li> <code>ignore_keys</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>any keys/fields in BaseModel not to print</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def pretty_list_of_basemodel_printer(\n    list_of_models: List[BaseModel], ignore_keys: Optional[List[str]] = None\n):\n    \"\"\"\n    renders a list to stdio given a list of pydantic BaseModel objects\n\n    Args:\n        list_of_models (List[BaseModel]): list of pydantic models to print\n        ignore_keys (Optional[List[str]], optional): any keys/fields in BaseModel not to print\n    \"\"\"\n    i = len(list_of_models) - 1\n    logger.info(\"------------------------\")\n    for element in reversed(list_of_models):\n        logger.info(i)\n        for k, v in element.model_dump().items():\n            if ignore_keys is not None:\n                if (\n                    k not in ignore_keys\n                ):  # print the key and value if not in ignore_keys or special_dict\n                    print(\"\\t%s - %s\" % (k, v))\n\n            else:  # (default case) print the key and value\n                print(\"\\t%s - %s\" % (k, v))\n        i -= 1\n        print(\"------------------------\")\n</code></pre>"},{"location":"songbirdcore/common/#songbirdcore.common.pretty_lst_printer","title":"<code>pretty_lst_printer(lyst)</code>","text":"<p>print a list to stdio</p> <p>Parameters:</p> <ul> <li> <code>lyst</code>               (<code>List</code>)           \u2013            <p>the list to print</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def pretty_lst_printer(lyst: List):\n    \"\"\"print a list to stdio\n\n    Args:\n        lyst (List): the list to print\n    \"\"\"\n    for idx, item in enumerate(lyst):\n        logger.info(f\"\\t [{idx}] - {item}\")\n</code></pre>"},{"location":"songbirdcore/common/#songbirdcore.common.remove_illegal_characters","title":"<code>remove_illegal_characters(filename)</code>","text":"<p>Used for stripping file names of illegal characters used for saving</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>the file's name to strip illegal characters from</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>stripped file name</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def remove_illegal_characters(filename) -&gt; str:\n    \"\"\"\n    Used for stripping file names of illegal characters used for saving\n\n    Args:\n        filename (str): the file's name to strip illegal characters from\n\n    Returns:\n        str: stripped file name\n    \"\"\"\n    return (\n        filename.replace(\"\\\\\", \"\")\n        .replace('\"', \"\")\n        .replace(\"/\", \"\")\n        .replace(\"*\", \"\")\n        .replace(\"?\", \"\")\n        .replace(\"&lt;\", \"\")\n        .replace(\"&gt;\", \"\")\n        .replace(\"|\", \"\")\n        .replace(\"'\", \"\")\n        .replace(\":\", \"\")\n    )\n</code></pre>"},{"location":"songbirdcore/common/#songbirdcore.common.set_logger_config_globally","title":"<code>set_logger_config_globally(log_level=logging.INFO)</code>","text":"<p>Sets the python logging module settings for output to stdout and to file.</p> <p>Parameters:</p> <ul> <li> <code>log_level</code>               (<code>str</code>, default:                   <code>INFO</code> )           \u2013            <p>the log level</p> </li> </ul> Source code in <code>songbirdcore/common.py</code> <pre><code>def set_logger_config_globally(log_level=logging.INFO) -&gt; None:\n    \"\"\"Sets the python logging module settings for output\n    to stdout and to file.\n\n    Args:\n        log_level (str): the log level\n\n    \"\"\"\n    logging.basicConfig(\n        level=log_level,\n        format=\"[%(levelname)s] %(name)s: %(message)s\",\n        handlers=[logging.StreamHandler()],\n    )\n</code></pre>"},{"location":"songbirdcore/gdrive/","title":"gdrive","text":""},{"location":"songbirdcore/gdrive/#songbirdcore.gdrive","title":"<code>songbirdcore.gdrive</code>","text":""},{"location":"songbirdcore/gdrive/#songbirdcore.gdrive.save_song","title":"<code>save_song(gdrive_folder_id, credentials_path, token_path, song_name, song_path, auth_port, bind_addr=None)</code>","text":"<p>save a song to google drive</p> <p>Parameters:</p> <ul> <li> <code>gdrive_folder_id</code>               (<code>str</code>)           \u2013            <p>google drive folder id</p> </li> <li> <code>credentials_path</code>               (<code>str</code>)           \u2013            <p>path to a credentials.json file</p> </li> <li> <code>token_path</code>               (<code>str</code>)           \u2013            <p>path to a google cloud token file</p> </li> <li> <code>song_name</code>               (<code>str</code>)           \u2013            <p>the name of the song (filename)</p> </li> <li> <code>song_path</code>               (<code>str</code>)           \u2013            <p>the path of the song locally</p> </li> <li> <code>auth_port</code>               (<code>int</code>)           \u2013            <p>the port to use for oauth</p> </li> <li> <code>bind_addr</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>optionally specify the bind address, otherwise localhost is used. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>the file id of the upload</p> </li> </ul> Source code in <code>songbirdcore/gdrive.py</code> <pre><code>def save_song(\n    gdrive_folder_id: str,\n    credentials_path: str,\n    token_path: str,\n    song_name: str,\n    song_path: str,\n    auth_port: int,\n    bind_addr: Optional[str] = None,\n) -&gt; str:\n    \"\"\"save a song to google drive\n\n    Args:\n        gdrive_folder_id (str): google drive folder id\n        credentials_path (str): path to a credentials.json file\n        token_path (str): path to a google cloud token file\n        song_name (str): the name of the song (filename)\n        song_path (str): the path of the song locally\n        auth_port (int): the port to use for oauth\n        bind_addr (Optional[str], optional): optionally specify the bind address, otherwise localhost is used. Defaults to None.\n\n    Returns:\n        str: the file id of the upload\n    \"\"\"\n    creds = None\n    # The file token.json stores the user's access and refresh tokens, and is\n    # created automatically when the authorization flow completes for the first\n    # time.\n    scopes = [\"https://www.googleapis.com/auth/drive\"]\n    if os.path.exists(token_path):\n        creds = Credentials.from_authorized_user_file(token_path, scopes)\n    # If there are no (valid) credentials available, let the user log in.\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(credentials_path, scopes)\n            creds = flow.run_local_server(\n                port=auth_port, bind_addr=bind_addr, open_browser=False\n            )\n        # Save the credentials for the next run\n        with open(token_path, \"w\") as token:\n            token.write(creds.to_json())\n\n    logger.debug(f\"Loaded credentials: {creds}\")\n    service = build(\"drive\", \"v3\", credentials=creds)\n\n    file_metadata = {\"name\": song_name, \"parents\": [gdrive_folder_id]}\n    media = http.MediaFileUpload(song_path, mimetype=\"audio/jpeg\")\n    file = (\n        service.files()\n        .create(body=file_metadata, media_body=media, fields=\"id\")\n        .execute()\n    )\n    file_id = file.get(\"id\")\n    logger.info(f\"File creation successful -- ID: {file_id}\")\n    return file_id\n</code></pre>"},{"location":"songbirdcore/itunes/","title":"itunes","text":""},{"location":"songbirdcore/itunes/#songbirdcore.itunes","title":"<code>songbirdcore.itunes</code>","text":""},{"location":"songbirdcore/itunes/#songbirdcore.itunes.artwork_searcher","title":"<code>artwork_searcher(url)</code>","text":"<p>Album artwork searcher.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>the url for the artwork</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Response</code> (              <code>Optional[Response]</code> )          \u2013            <p>the response for the artwork request</p> </li> </ul> Source code in <code>songbirdcore/itunes.py</code> <pre><code>def artwork_searcher(url: str) -&gt; Optional[Response]:\n    \"\"\"Album artwork searcher.\n\n    Args:\n        url (str): the url for the artwork\n\n    Returns:\n        Response: the response for the artwork request\n    \"\"\"\n    artwork_size_list = [\n        \"100x100\",\n        \"500x500\",\n        \"1000x1000\",\n        \"1500x1500\",\n        \"2000x2000\",\n        \"2500x2500\",\n        \"3000x3000\",\n    ]\n    i = len(artwork_size_list) - 1\n\n    response = requests.get(url.replace(\"100x100\", artwork_size_list[i]))\n    while response.status_code != 200 and i != 0:\n        logger.info(f\"- Size not found -- Trying size: {artwork_size_list[i]}\")\n        response = requests.get(url.replace(\"100x100\", artwork_size_list[i]))\n        i -= 1\n\n    if i == 0:\n        logger.info(\"Couldnt find album art. Your file wont have the art.\")\n        return None\n\n    else:\n        logger.info(f\"Found art at size: {artwork_size_list[i]}\")\n\n    return response\n</code></pre>"},{"location":"songbirdcore/itunes/#songbirdcore.itunes.itunes_lib_search","title":"<code>itunes_lib_search(itunes_lib_path, search_parameters, album_properties=None)</code>","text":"<p>Performs a search on users iTunes library by album, artist and genre</p> <p>Parameters:</p> <ul> <li> <code>itunes_lib_path</code>               (<code>str</code>)           \u2013            <p>path to itunes song library on disk</p> </li> <li> <code>search_parameters</code>               (<code>str</code>)           \u2013            <p>search term</p> </li> <li> <code>album_properties</code>               (<code>ItunesApiAlbumKeys</code>, default:                   <code>None</code> )           \u2013            <p>determines whether to do a smarter search based on given album properties</p> </li> </ul> <p>Returns: a list of songpaths found</p> Source code in <code>songbirdcore/itunes.py</code> <pre><code>def itunes_lib_search(\n    itunes_lib_path: str,\n    search_parameters: str,\n    album_properties: Optional[itunes_api.ItunesApiAlbumKeys] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Performs a search on users iTunes library by album, artist and genre\n\n    Args:\n        itunes_lib_path (str): path to itunes song library on disk\n        search_parameters (str): search term\n        album_properties (itunes_api.ItunesApiAlbumKeys): determines whether to do a smarter search based on given album properties\n\n    Returns: a list of songpaths found\n    \"\"\"\n    itunes_songs = glob.glob(\n        os.path.join(itunes_lib_path, \"*\", \"*\", f\"*.*\"), recursive=True\n    )\n    matches = []\n    for song_path in itunes_songs:\n        # song_name_split is list of itunes file path.. artist is -3 from length, song is -1\n        song_name_split = song_path.split(os.sep)\n        song_name = common.remove_illegal_characters(\n            song_name_split[len(song_name_split) - 1].lower()\n        )\n        album_name = common.remove_illegal_characters(\n            song_name_split[len(song_name_split) - 2].lower()\n        )\n        artist_name = common.remove_illegal_characters(\n            song_name_split[len(song_name_split) - 3].lower()\n        )\n        search_parameters = common.remove_illegal_characters(search_parameters.lower())\n        if album_properties == None:\n            formatted_name = song_name + \" \" + album_name + \" \" + artist_name\n            if search_parameters in formatted_name:\n                matches.append(song_path)\n        else:\n            if (\n                album_properties.artistName.lower() in artist_name\n                and search_parameters in song_name\n            ):\n                matches.append(song_path)\n\n    # returns sorted alphabetical list of matches.\n    matches.sort()\n    return matches\n</code></pre>"},{"location":"songbirdcore/itunes/#songbirdcore.itunes.m4a_tagger","title":"<code>m4a_tagger(file_path, song_tag_data)</code>","text":"<p>Tag an m4a file using iTunes recognized tags.</p> <p>The below is a tag legend taken from mutagen website. Text values:</p> <pre><code>'\\xa9nam' - track title\n'\\xa9alb' - album\n'\\xa9ART' - artist\n'aART' - album artist\n'\\xa9day' - year\n'purd' - purchase date\n'\\xa9gen' - genre\nTuples of ints (multiple values per key are supported):\n'trkn' - track number, total tracks\n'disk' - disc number, total discs\n'covr' - cover artwork, list of MP4Cover objects (which are tagged strs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>str</code>)           \u2013            <p>path to the m4a file</p> </li> <li> <code>song_tag_data</code>               (<code>ItunesApiSongModel</code>)           \u2013            <p>The model for the songs relevant metadata collected from itunes search api</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>true if tagging was successful.</p> </li> </ul> Source code in <code>songbirdcore/itunes.py</code> <pre><code>def m4a_tagger(file_path: str, song_tag_data: itunes_api.ItunesApiSongModel) -&gt; bool:\n    \"\"\"Tag an m4a file using iTunes recognized tags.\n\n    The below is a tag legend taken from mutagen website.\n    Text values:\n\n    ```\n    '\\\\xa9nam' - track title\n    '\\\\xa9alb' - album\n    '\\\\xa9ART' - artist\n    'aART' - album artist\n    '\\\\xa9day' - year\n    'purd' - purchase date\n    '\\\\xa9gen' - genre\n    Tuples of ints (multiple values per key are supported):\n    'trkn' - track number, total tracks\n    'disk' - disc number, total discs\n    'covr' - cover artwork, list of MP4Cover objects (which are tagged strs)\n    ```\n\n    Args:\n        file_path (str): path to the m4a file\n        song_tag_data (itunes_api.ItunesApiSongModel): The model for the songs relevant metadata collected from itunes search api\n\n    Returns:\n        bool: true if tagging was successful.\n    \"\"\"\n    try:\n        logger.info(f\"Adding tags to m4a file : {file_path}\")\n\n        response = artwork_searcher(url=song_tag_data.artworkUrl100)\n        audiofile = MP4(file_path)\n\n        # Set all the tags for the mp3, all without if statement were checked for existence.\n        audiofile[\"\\xa9ART\"] = song_tag_data.artistName\n        audiofile[\"\\xa9alb\"] = song_tag_data.collectionName\n        audiofile[\"\\xa9nam\"] = song_tag_data.trackName\n        audiofile[\"\\xa9gen\"] = song_tag_data.primaryGenreName\n        audiofile[\"trkn\"] = [(song_tag_data.trackNumber, song_tag_data.trackCount)]\n        audiofile[\"disk\"] = [(song_tag_data.discNumber, song_tag_data.discCount)]\n        audiofile[\"\\xa9day\"] = song_tag_data.releaseDate\n\n        if (\n            song_tag_data.collectionArtistName is not None\n        ):  # check if collection_artist_name exists before adding to tags\n            audiofile[\"aART\"] = song_tag_data.collectionArtistName\n\n        if response.status_code == 200:\n            audiofile[\"covr\"] = [\n                MP4Cover(response.content, imageformat=MP4Cover.FORMAT_PNG)\n            ]\n\n        audiofile.save()\n        logger.info(\"Your tags have been set.\")\n        return True\n    except Exception as e:\n        logger.exception(\n            f\"Unexpected error occured while trying to tag your m4a file: {e}\"\n        )\n        return False\n</code></pre>"},{"location":"songbirdcore/itunes/#songbirdcore.itunes.mp3ID3Tagger","title":"<code>mp3ID3Tagger(mp3_path, song_tag_data)</code>","text":"<p>Tags an mp3 file at mp3_path given a itunes_api.ItunesApiSongModel object</p> <p>Parameters:</p> <ul> <li> <code>mp3_path</code>               (<code>str</code>)           \u2013            <p>file path of mp3 file</p> </li> <li> <code>song_tag_data</code>               (<code>ItunesApiSongModel</code>)           \u2013            <p>the model with tag fields</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>true if tagging was a success</p> </li> </ul> Source code in <code>songbirdcore/itunes.py</code> <pre><code>def mp3ID3Tagger(mp3_path: str, song_tag_data: itunes_api.ItunesApiSongModel) -&gt; bool:\n    \"\"\"\n    Tags an mp3 file at mp3_path given a itunes_api.ItunesApiSongModel object\n\n    Args:\n        mp3_path (str): file path of mp3 file\n        song_tag_data (itunes_api.ItunesApiSongModel): the model with tag fields\n\n    Returns:\n        bool: true if tagging was a success\n    \"\"\"\n    try:\n        # Create MP3File instance.\n        logger.info(f\"Adding your tags to mp3 file: {mp3_path}\")\n        # Have to call MP3File twice for it to work.\n\n        # Get the image to show for a song .. but get high res\n        # get album artwork from the list of sizes\n\n        response = artwork_searcher(url=song_tag_data.artworkUrl100)\n\n        # Set all the tags for the mp3, all without if statement were checked for existence.\n        audiofile = eyed3.load(mp3_path)\n        audiofile.tag.artist = song_tag_data.artistName\n        audiofile.tag.album = song_tag_data.collectionName\n        audiofile.tag.title = song_tag_data.trackName\n        audiofile.tag.genre = song_tag_data.primaryGenreName\n        audiofile.tag.track_num = (song_tag_data.trackNumber, song_tag_data.trackCount)\n        audiofile.tag.disc_num = (song_tag_data.discNumber, song_tag_data.discCount)\n        audiofile.tag.recording_date = song_tag_data.releaseDate\n\n        if (\n            song_tag_data.collectionArtistName is not None\n        ):  # check if collection_artist_name exists before adding to tags\n            audiofile.tag.album_artist = song_tag_data.collectionArtistName\n\n        if response.status_code == 200:\n            audiofile.tag.images.set(\n                type_=3,\n                img_data=response.content,\n                mime_type=\"image/png\",\n                description=\"Art\",\n                img_url=None,\n            )\n\n        audiofile.tag.save()\n        logger.info(\"Your tags have been set.\")\n        return True\n\n    except Exception as e:\n        logger.exception(\n            f\"Unexpected error occured while trying to tag your mp3 file: {e}\"\n        )\n        return False\n</code></pre>"},{"location":"songbirdcore/itunes/#songbirdcore.itunes.query_api","title":"<code>query_api(search_variable, limit, mode, lookup=False)</code>","text":"<p>Parameters:</p> <ul> <li> <code>search_variable</code>               (<code>str</code>)           \u2013            <p>the term to search itunes api for</p> </li> <li> <code>limit</code>               (<code> (int</code>)           \u2013            <p>limit of the search in the api</p> </li> <li> <code>mode</code>               (<code>Modes</code>)           \u2013            <p>value of album, or song for now</p> </li> <li> <code>lookup</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if true, perform a lookup search via itunes api rather than a default search</p> </li> </ul> <p>Returns     List[Union[itunes_api.ItunesApiSongModel, itunes_api.ItunesApiAlbumKeys]]: a list containing a         tuple with itunes song properties and album properties</p> Source code in <code>songbirdcore/itunes.py</code> <pre><code>def query_api(\n    search_variable: str, limit: int, mode: modes.Modes, lookup: bool = False\n) -&gt; List[Union[itunes_api.ItunesApiSongModel, itunes_api.ItunesApiAlbumKeys]]:\n    \"\"\"\n    Args:\n        search_variable (str): the term to search itunes api for\n        limit  (int): limit of the search in the api\n        mode (modes.Modes): value of album, or song for now\n        lookup (bool): if true, perform a lookup search via itunes api rather than a default search\n    Returns\n        List[Union[itunes_api.ItunesApiSongModel, itunes_api.ItunesApiAlbumKeys]]: a list containing a\n            tuple with itunes song properties and album properties\n    \"\"\"\n    parsed_results_list = []\n    result_dict = {}\n    if not lookup:  # perform general search\n        search_parameters = {\n            \"term\": search_variable,\n            \"entity\": mode.value,\n            \"limit\": limit,\n        }\n        itunes_response = requests.get(\n            \"https://itunes.apple.com/search\", params=search_parameters\n        )\n    else:  # perform lookup query by itunes id\n        search_parameters = {\n            \"id\": search_variable,\n            \"entity\": mode.value,\n            \"limit\": limit,\n        }\n        itunes_response = requests.get(\n            \"https://itunes.apple.com/lookup\", params=search_parameters\n        )\n\n    # itunesResponse = requests.get('https://itunes.apple.com/search?term=jack+johnson')\n    logger.info(f\"Connected to {itunes_response.url}\")\n    if itunes_response.status_code != 200:\n        logger.error(\n            \"Oops. Something went wrong trying to connect to the itunes server.\"\n        )\n        logger.error(\n            f\"Code: {itunes_response.status_code}, Body: {itunes_response.content}\"\n        )\n        return None\n\n    itunes_json_dict = json.loads(itunes_response.content)\n    for index, search_result in enumerate(itunes_json_dict[\"results\"]):\n        try:\n            if mode == modes.Modes.SONG:\n                result = itunes_api.ItunesApiSongModel.model_validate(search_result)\n                year = search_result[result.releaseDateKey].split(\"-\")[\n                    0\n                ]  # will grab the year from date formatted 2016-06-01\n                result.releaseDate = year\n            elif mode == modes.Modes.ALBUM:\n                result = itunes_api.ItunesApiAlbumKeys.model_validate(search_result)\n\n            parsed_results_list.append(result)\n        except ValidationError as e:\n            logger.warning(\n                f\"Skipping the display of song at index [{index}] as it could not be loaded into expected format.\\n{e}\"\n            )\n\n    return parsed_results_list\n</code></pre>"},{"location":"songbirdcore/web/","title":"web","text":""},{"location":"songbirdcore/web/#songbirdcore.web","title":"<code>songbirdcore.web</code>","text":""},{"location":"songbirdcore/web/#songbirdcore.web.SimpleSession","title":"<code>SimpleSession(name, root_url, credentials={}, headers={})</code>","text":"Source code in <code>songbirdcore/web.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    root_url: str,\n    credentials: Optional[dict] = {},\n    headers: Optional[dict] = {},\n):\n    self.name = name\n    self.root_url = root_url\n    self.credentials = {}\n    self.headers = headers\n    if headers is None:\n        self.headers = {  # default header is copied from linux pc after submitting request\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n            \"Accept-Encoding\": \"gzip, deflate, br\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Connection\": \"keep-alive\",\n            \"Host\": \"www.youtube.com\",\n            \"Sec-Fetch-Dest\": \"document\",\n            \"Sec-Fetch-Mode\": \"navigate\",\n            \"Sec-Fetch-Site\": \"cross-site\",\n            \"Upgrade-Insecure-Requests\": \"1\",\n            \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36\",\n        }\n    self.current_url = \"\"\n\n    # initialize a session for this class.. to be used for all requests\n    self.s = HTMLSession()\n</code></pre>"},{"location":"songbirdcore/web/#songbirdcore.web.SimpleSession.enter_search_form","title":"<code>enter_search_form(search_url, form_url=None, payload=None, render_timeout=10, render_wait=0.2, render_sleep=1, log_calls=True)</code>","text":"<p>Enter into a search form for a website Args:     form_url (Optional[str]): the url for the html form. If not passed, uses the root_url for the class.     search_url (str): the url to perform the search against     payload (Optional[dict]): optionally include a payload for the request</p> <p>Returns:</p> <ul> <li> <code>Optional[Response]</code>           \u2013            <p>Optional[Response]: the rendered html response, or None if failure occurs</p> </li> </ul> Source code in <code>songbirdcore/web.py</code> <pre><code>def enter_search_form(\n    self,\n    search_url: str,\n    form_url: Optional[str] = None,\n    payload: Optional[dict] = None,\n    render_timeout: Optional[int] = 10,\n    render_wait: Optional[float] = 0.2,\n    render_sleep: Optional[int] = 1,\n    log_calls: Optional[bool] = True,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Enter into a search form for a website\n    Args:\n        form_url (Optional[str]): the url for the html form. If not passed, uses the root_url for the class.\n        search_url (str): the url to perform the search against\n        payload (Optional[dict]): optionally include a payload for the request\n\n    Returns:\n        Optional[Response]: the rendered html response, or None if failure occurs\n    \"\"\"\n    if form_url is None:\n        form_url = self.root_url\n\n    form_inputs = self.get_form_inputs(form_url, payload, log_calls)\n\n    if form_inputs is None:\n        return None\n    try:\n        response = self.s.get(search_url, params=form_inputs, headers=self.headers)\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error submitting request to: {search_url}\", e)\n        return None\n\n    logger.debug(\"Rendering html for : \" + response.url)\n    response.html.render(\n        timeout=render_timeout, wait=render_wait, sleep=render_sleep\n    )\n    logger.debug(\"Rendering complete for : \" + response.url)\n\n    response.close()\n    return response\n</code></pre>"},{"location":"songbirdcore/web/#songbirdcore.web.SimpleSession.get_form_inputs","title":"<code>get_form_inputs(form_url, payload={}, log_calls=True)</code>","text":"<p>Get the inputs for a form on a webpage</p> <p>Parameters:</p> <ul> <li> <code>form_url</code>               (<code>str</code>)           \u2013            <p>the url for the form</p> </li> <li> <code>payload</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>the payload to insert into the form. Defaults to {}.</p> </li> <li> <code>log_calls</code>               (<code>Optional[bool]</code>, default:                   <code>True</code> )           \u2013            <p>whether to log information within this method</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[dict]</code>           \u2013            <p>Optional[dict]: a dictionary containing the form inputs for the form_url, updated with payload</p> </li> </ul> Source code in <code>songbirdcore/web.py</code> <pre><code>def get_form_inputs(\n    self, form_url: str, payload={}, log_calls: Optional[bool] = True\n) -&gt; Optional[dict]:\n    \"\"\"Get the inputs for a form on a webpage\n\n    Args:\n        form_url (str): the url for the form\n        payload (dict, optional): the payload to insert into the form. Defaults to {}.\n        log_calls (Optional[bool], optional): whether to log information within this method\n\n    Returns:\n        Optional[dict]: a dictionary containing the form\n            inputs for the form_url, updated with payload\n    \"\"\"\n    # initialize form_inputs to be empty each request\n    form_inputs = {}\n    try:\n        form_response = self.s.get(form_url, headers=self.headers)\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error submitting request to: {form_url}\", e)\n        return None\n\n    if log_calls:\n        logger.info(f\"Loaded web page: {form_response.url}!\")\n    # incase you want to parse through the login page.. see below comment\n    inputs = form_response.html.find(\"input\")\n\n    # adds the csrf middleware tokens to login details.. usually stored\n    # in &lt;name&gt; and &lt;value&gt; html tags\n    for inputfield in inputs:\n        key = inputfield.attrs[\"name\"]\n        form_inputs.update({key: \"\"})\n\n    # remove None type attributes\n    try:\n        form_inputs.pop(None)\n    except KeyError:\n        logger.debug(\"No nonetype attributes to be removed.\")\n\n    form_inputs.update(payload)\n    if log_calls:\n        logger.info(f\"Auto filled the web form with inputs: {form_inputs}\")\n\n    form_response.close()\n    return form_inputs\n</code></pre>"},{"location":"songbirdcore/youtube/","title":"youtube","text":""},{"location":"songbirdcore/youtube/#songbirdcore.youtube","title":"<code>songbirdcore.youtube</code>","text":""},{"location":"songbirdcore/youtube/#songbirdcore.youtube.YtDlLogger","title":"<code>YtDlLogger</code>","text":"<p>               Bases: <code>object</code></p> <p>Used for setting up youtube_dl logging</p>"},{"location":"songbirdcore/youtube/#songbirdcore.youtube.get_video_links","title":"<code>get_video_links(youtube_home_url, youtube_search_url, youtube_query_payload, render_timeout, render_wait, retry_count=3, render_sleep=1)</code>","text":"<p>Parameters:</p> <ul> <li> <code>render_timeout</code>               (<code>int</code>)           \u2013            <p>amount of time before abandoning a render</p> </li> <li> <code>render_wait</code>               (<code>float</code>)           \u2013            <p>the amount of time before attempting a render</p> </li> <li> <code>retry_count</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>the number of retries for a render</p> </li> <li> <code>render_sleep</code>               (<code>Optional[int]</code>, default:                   <code>1</code> )           \u2013            <p>the amount of time to wait after rendering</p> </li> </ul> Source code in <code>songbirdcore/youtube.py</code> <pre><code>def get_video_links(\n    youtube_home_url: str,\n    youtube_search_url: str,\n    youtube_query_payload: dict,\n    render_timeout: int,\n    render_wait: float,\n    retry_count: Optional[int] = 3,\n    render_sleep: Optional[int] = 1,\n) -&gt; Tuple[List[str], List[requests_html.Element]]:\n    \"\"\"\n    Args:\n        render_timeout (int): amount of time before abandoning a render\n        render_wait (float): the amount of time before attempting a render\n        retry_count (int): the number of retries for a render\n        render_sleep (Optional[int]): the amount of time to wait after rendering\n    \"\"\"\n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\",  # ubuntu chrome headers\n        \"Referrer\": youtube_home_url,\n    }\n    session = web.SimpleSession(\"youtube\", root_url=youtube_home_url, headers=headers)\n    tries = 0\n    # Only need to log info about these requests on first try to simplify UI experience\n    log_attempts = True\n    while tries &lt; retry_count:\n        # First, enter the search form on the youtube home page\n        response = session.enter_search_form(\n            search_url=youtube_search_url,\n            payload=youtube_query_payload,\n            render_timeout=render_timeout,\n            render_wait=render_wait,\n            render_sleep=render_sleep,\n            log_calls=log_attempts,\n        )\n        if response == None:\n            logger.error(\n                f\"Error occurred performing a search for {youtube_query_payload} against url {youtube_search_url}. Please try again.\"\n            )\n            tries += 1\n            log_attempts = False\n            continue\n        # Get the list of hrefs to each video on the home page\n        links = response.html.find(\"#video-title\")\n        if len(links) == 0:\n            logger.warning(f\"{tries+1}:{retry_count}.\")\n            tries += 1\n            log_attempts = False\n        else:\n            break\n    session.close()\n    if tries &gt;= retry_count:\n        logger.error(\n            f\"Failed to get links from {youtube_home_url} after {retry_count} tries.\"\n        )\n        return None, None\n\n    link_list = []\n    # create a user friendly list, containing videos with title and href refs.\n    for idx, link in enumerate(links):\n        if \"title\" in link.attrs and \"href\" in link.attrs:\n            link_list.append(\n                f\"{link.attrs['title']} - {youtube_home_url+link.attrs['href']}\"\n            )\n        # the actual raw list should match list size so we can properly select the link after.\n        else:\n            links.pop(idx)\n\n    return link_list, links\n</code></pre>"},{"location":"songbirdcore/youtube/#songbirdcore.youtube.my_hook","title":"<code>my_hook(d)</code>","text":"<p>Hook for youtube_dl Args:     d: download object from youtube_dl</p> Source code in <code>songbirdcore/youtube.py</code> <pre><code>def my_hook(d):\n    \"\"\"\n    Hook for youtube_dl\n    Args:\n        d: download object from youtube_dl\n    \"\"\"\n    if d[\"status\"] == \"finished\":\n        sys.stdout.write(\"\\n\")\n        logger.info(\"Done downloading, now converting ...\")\n\n    if d[\"status\"] == \"downloading\":\n        p = d[\"_percent_str\"]\n        p = p.replace(\"%\", \"\")\n        song_name = d[\"filename\"].split(os.sep)[-1]\n        sys.stdout.write(\n            f\"\\rDownloading to file: {song_name}, {d['_percent_str']}, {d['_eta_str']}\"\n        )\n        sys.stdout.flush()\n    if d[\"status\"] == \"error\":\n        logger.error(\"Error occured during download.\")\n        success_downloading = False\n</code></pre>"},{"location":"songbirdcore/youtube/#songbirdcore.youtube.run_download","title":"<code>run_download(url, file_path_no_format, file_format, embed_thumbnail=False)</code>","text":"<p>Run a download from youtube</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>the url to download</p> </li> <li> <code>file_path_no_format</code>               (<code>str</code>)           \u2013            <p>the file path excluding file format</p> </li> <li> <code>file_format</code>               (<code>str</code>)           \u2013            <p>the file format</p> </li> <li> <code>embed_thumbnail</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>set to True to embed the youtube thumbnail into the downloaded file</p> </li> </ul> <p>Returns:     str: the filepath.</p> Source code in <code>songbirdcore/youtube.py</code> <pre><code>def run_download(\n    url: str, file_path_no_format: str, file_format: str, embed_thumbnail: bool = False\n) -&gt; Optional[str]:\n    \"\"\"Run a download from youtube\n\n    Args:\n        url (str): the url to download\n        file_path_no_format (str): the file path excluding file format\n        file_format (str): the file format\n        embed_thumbnail (bool): set to True to embed the youtube thumbnail into the downloaded file\n    Returns:\n        str: the filepath.\n    \"\"\"\n    local_file_path = f\"{file_path_no_format}.{file_format}\"\n    ydl_opts = {\n        \"format\": \"bestaudio/best\",\n        \"cachedir\": False,\n        \"postprocessors\": [\n            {\"key\": \"FFmpegMetadata\", \"add_metadata\": True},\n            {\n                \"key\": \"FFmpegExtractAudio\",\n                \"preferredcodec\": file_format,\n                \"preferredquality\": \"192\",\n            },\n        ],\n        \"nocheckcertificate\": True,\n        \"logger\": YtDlLogger(),\n        \"progress_hooks\": [my_hook],\n        \"outtmpl\": file_path_no_format + \".%(ext)s\",\n    }\n    if embed_thumbnail:\n        ydl_opts[\"writethumbnail\"] = True\n        ydl_opts[\"embedthumbnail\"] = True\n        ydl_opts[\"postprocessors\"].append(\n            {\n                \"key\": \"EmbedThumbnail\",\n            }\n        )\n    try:\n        with youtube_dl.YoutubeDL(ydl_opts) as ydl:\n            error_code = ydl.download(url)\n        if error_code:\n            logger.error(\n                f\"received error code from yt-dlp --- could not perform download at url {url}.\"\n            )\n            return None\n        logger.info(f\"Downloading successful. File stored locally: {local_file_path}\")\n        return local_file_path\n    except Exception as e:\n        logger.exception(f\"Failed to complete the download of song at url: {url}.\")\n        return None\n</code></pre>"},{"location":"songbirdcore/models/itunes_api/","title":"itunes_api","text":""},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api","title":"<code>songbirdcore.models.itunes_api</code>","text":""},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiAlbumKeys","title":"<code>ItunesApiAlbumKeys</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiAlbumKeys.artistName","title":"<code>artistName</code>  <code>instance-attribute</code>","text":"<p>specifies artist name for album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiAlbumKeys.collectionId","title":"<code>collectionId = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>specified itunes api collection id</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiAlbumKeys.collectionName","title":"<code>collectionName</code>  <code>instance-attribute</code>","text":"<p>specifies artist name for collection</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiAlbumKeys.trackCount","title":"<code>trackCount</code>  <code>instance-attribute</code>","text":"<p>specifies number of songs in album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel","title":"<code>ItunesApiSongModel</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.artistName","title":"<code>artistName</code>  <code>instance-attribute</code>","text":"<p>specifies song artist name</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.artworkUrl100","title":"<code>artworkUrl100</code>  <code>instance-attribute</code>","text":"<p>specifies url pointing to album artwork</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.collectionArtistName","title":"<code>collectionArtistName = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>specifies artist name for the album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.collectionId","title":"<code>collectionId = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>specifies id for the album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.collectionName","title":"<code>collectionName</code>  <code>instance-attribute</code>","text":"<p>specifies album name</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.discCount","title":"<code>discCount</code>  <code>instance-attribute</code>","text":"<p>specifies disc count in album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.discNumber","title":"<code>discNumber</code>  <code>instance-attribute</code>","text":"<p>specifies disc number in album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.primaryGenreName","title":"<code>primaryGenreName</code>  <code>instance-attribute</code>","text":"<p>specifies genre name for the song</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.releaseDate","title":"<code>releaseDate</code>  <code>instance-attribute</code>","text":"<p>specifies release date of album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.releaseDateKey","title":"<code>releaseDateKey = 'releaseDate'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>specifies key expected for releaseDate field in itunes api response object</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.trackCount","title":"<code>trackCount</code>  <code>instance-attribute</code>","text":"<p>specifies number of songs in album</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.trackName","title":"<code>trackName</code>  <code>instance-attribute</code>","text":"<p>specifies song name</p>"},{"location":"songbirdcore/models/itunes_api/#songbirdcore.models.itunes_api.ItunesApiSongModel.trackNumber","title":"<code>trackNumber</code>  <code>instance-attribute</code>","text":"<p>specifies song number in album</p>"},{"location":"songbirdcore/models/modes/","title":"modes","text":""},{"location":"songbirdcore/models/modes/#songbirdcore.models.modes","title":"<code>songbirdcore.models.modes</code>","text":""},{"location":"songbirdcore/models/modes/#songbirdcore.models.modes.Modes","title":"<code>Modes</code>","text":"<p>               Bases: <code>Enum</code></p> <p>enum class containing songbirdcore modes</p>"},{"location":"songbirdcore/models/modes/#songbirdcore.models.modes.Modes.ALBUM","title":"<code>ALBUM = 'album'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Specifies album mode</p>"},{"location":"songbirdcore/models/modes/#songbirdcore.models.modes.Modes.SONG","title":"<code>SONG = 'song'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Specifies song mode</p>"}]}